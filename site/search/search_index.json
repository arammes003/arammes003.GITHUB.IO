{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Inicio","text":""},{"location":"#bienvenido-al-mkdocs-de-alfonso-ramirez-mestanza","title":"Bienvenido al Mkdocs de Alfonso Ram\u00edrez Mestanza","text":"<p>En este mkdocs, encontrar\u00e1s todas las pr\u00e1cticas de la asignatura de <code>Despligue de Aplicaciones Web</code> del alumno <code>Alfonso Ram\u00edrez Mestanza</code> de <code>2\u00ba DAW-B</code> del instituto <code>IES Gran Capit\u00e1n</code>.</p>"},{"location":"practica-amplicacion/","title":"Pr\u00e1ctica de Amplicaci\u00f3n.- Configuraci\u00f3n de un servidor Nginx con Hosts Virtuales y directorios de usuario","text":"<p>El fin de esta pr\u00e1ctica es configurar un servidor Nginx que utilice hosts virtuales para alojar m\u00faltiples sitios web en un mismo servidor y que a su vez, cada host virtual apunte al directorio public_html de distintos usuarios del sistema operativo Debian. De esta manera, cada usuario podr\u00e1 gestionar su propio sitio web desde su carpeta personal.</p> <p>Antes de empezar a seguir los pasos para esta configuraci\u00f3n, nos conectaremos mediante <code>SSH</code> desde nuestra m\u00e1quina a la m\u00e1quina Debian. Para ello usamos el comando <code>ssh nombreUsuario@direccionIP</code>. </p>"},{"location":"practica-amplicacion/#1-instalacion-de-nginx","title":"1.- Instalaci\u00f3n de Nginx","text":"<p>El primer paso para instalar nginx es actualizar los repositorios del sistema mediante <code>sudo apt update</code> y <code>sudo apt upgrade</code>. </p> <p>Para instalar nginx usamos el comando <code>sudo apt install nginx -y</code>.  </p> <p>Iniciamos el servicio con <code>sudo systemctl start nginx</code> y despues verificamos que est\u00e9 funcionando correctamente con <code>sudo systemctl status nginx</code>. </p> <p>Si esta todo bien, veremos un mensaje en color verde, que pondra <code>active(running)</code>.</p>"},{"location":"practica-amplicacion/#2-creacion-de-usuarios-del-sistema","title":"2.- Creaci\u00f3n de usuarios del sistema.","text":"<p>En este paso, crearemos dos usuarios con contrase\u00f1as seguras con el comando <code>sudo adduser nombreUsuario</code>, en mi caso sera <code>usuario</code> y <code>usuario2</code>. </p>"},{"location":"practica-amplicacion/#3-estructura-de-carpetas-y-archivos","title":"3.- Estructura de carpetas y Archivos.","text":"<ol> <li> <p>El primer paso ser\u00e1 crear la carpeta <code>public_html</code> en los directorios de cada usuario con <code>sudo mkdir /home/nombreUsuario/public_html</code>. </p> </li> <li> <p>Despu\u00e9s, asignamos los permisos a cada usuario sobre su directorio con el comando <code>sudo chown -R nombreUsuario:nombreUsuario /home/nombreUsuario/public_html</code> y <code>sudo chmod 755 /home/nombreUsuario</code>. Este proceso hay que hacerlo con ambos usuarios. </p> </li> <li> <p>Por \u00faltimo, creamos una p\u00e1gina web de prueba en la carpeta <code>public_html</code> de cada usuario. Para ello, cambiamos de usuario con <code>su nombreUsuario</code> y creamos el archivo de la p\u00e1gina web con el comando <code>echo \"&lt;h1&gt;Bienvenido al sitio de nombreUsuario&lt;/h1&gt;\" &gt; /home/nombreUsuario/public_html/index.html</code>. Este proceso lo repetimos con ambos usuarios.     </p> </li> </ol>"},{"location":"practica-amplicacion/#4-configuracion-basica-de-nginx","title":"4.- Configuraci\u00f3n b\u00e1sica de Nginx","text":"<p>En este paso borraremos los sitios habilitados en nuestro servidor de Nginx para evitar posibles conflictos. En caso de haber hecho una instalaci\u00f3n limpia, solamente tendremos que borrar <code>default</code> con el comando <code>sudo rm /etc/nginx/sites-enabled/default</code>. </p> <p>Podemos verificar si se ha borrado correctamente con el comando <code>ls</code>. </p>"},{"location":"practica-amplicacion/#5-creacion-de-host-virtuales","title":"5.- Creaci\u00f3n de host virtuales","text":""},{"location":"practica-amplicacion/#51-creacion-de-archivos-de-configuracion","title":"5.1.- Creaci\u00f3n de archivos de configuraci\u00f3n","text":"<p>Aqu\u00ed crearemos dos archivos de configuraci\u00f3n de host virtual en <code>/etc/nginx/sites-available/</code>, uno para cada usuario. Para ello usamos el comando <code>sudo nano /etc/nginx/sites-available/nombreDescriptivo</code>.</p> <p>Se nos abrir\u00e1 una ventana vac\u00eda donde tendremos que implementar la siguiente configuraci\u00f3n: </p> <pre><code>server {\n    listen 80;\n    server_name usuario1.local;\n\n    root /home/usuario1/public_html;\n    index index.html;\n\n    location / {\n        try_files $uri $uri/ =404;\n    }\n}\n</code></pre> <p></p> <p>Ahora realizamos los mismos pasos para el segundo usuario. </p>"},{"location":"practica-amplicacion/#52-habilitar-los-enlaces-simbolicos","title":"5.2.- Habilitar los enlaces simb\u00f3licos","text":"<p>En este paso crearemos los enlaces simb\u00f3licos de ambas p\u00e1ginas con <code>sudo ln -s sudo ln -s /etc/nginx/sites-available/nombreUsuario /etc/nginx/sites-enabled/</code>. Con este comando habilitamos nuestra p\u00e1gina. </p> <p>Verificamos la configuracion con <code>sudo nginx -t</code> para asegurarnos que no hay errores. </p> <p>Y por ultimo, reiniciamos Nginx con <code>sudo systemctl restart nginx</code>. </p>"},{"location":"practica-amplicacion/#6-configuracion-del-archivo-host","title":"6.- Configuraci\u00f3n del archivo host","text":"<p>Para que nuestras p\u00e1ginas funcionen, deberemos editar nuestro fichero <code>hosts</code> en tu sistema local para poder resolver los dominios creados y as\u00ed poder acceder. En Windows, editamos <code>C:\\Windows\\System32\\drivers\\etc\\hosts.</code> y ponemos lo siguiente: </p> <p>Guardamos los cambios y accedemos a nuestro navegador para ver el contenido:  </p>"},{"location":"practica-amplicacion/#7-implementacion-de-conexion-segura","title":"7.- Implementaci\u00f3n de conexi\u00f3n segura","text":"<p>Ahora que sabemos que podemos acceder a nuestros sitios webs, los modificaremos para acceder mediante <code>HTTPS</code>, para ello, lo primero que tendremos que hacer es generar un <code>certificado SSL</code>, para ello lo primero que hacemos es crearnos un directorio donde guardarlos con <code>sudo mkdir /etc/nginx/ssl</code>. </p> <p>Despu\u00e9s, nos creamos nuestro certificado ssl con: </p> <pre><code>sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 \\\n  -keyout /etc/nginx/ssl/nginx-selfsigned.key \\\n  -out /etc/nginx/ssl/nginx-selfsigned.crt\n</code></pre> <p>En el proceso de creaci\u00f3n, nos pedir\u00e1 distintos datos para la creaci\u00f3n del certificado. </p>"},{"location":"practica-amplicacion/#71-modificacion-de-los-archivos-de-configuracion","title":"7.1.- Modificaci\u00f3n de los archivos de configuraci\u00f3n","text":"<p>Ahora actualizamos la configuraci\u00f3n de los hosts virtuales con <code>sudo nano /etc/nginx/sites-available/nombreArchivo</code> donde introduciremos una nueva secci\u00f3n para agregar el bloque <code>HTTPS</code>.</p> <pre><code>server {\n    listen 443 ssl;\n    server_name usuario1.local;\n\n    ssl_certificate /etc/nginx/ssl/nginx-selfsigned.crt;\n    ssl_certificate_key /etc/nginx/ssl/nginx-selfsigned.key;\n\n    root /home/usuario1/public_html;\n    index index.html;\n\n    location / {\n        try_files $uri $uri/ =404;\n    }\n}\n</code></pre> <p>Quedar\u00eda de la siguiente manera: </p> <p>Ahora repetimos el proceso con el otro archivo de configuraci\u00f3n.</p> <p></p> <p>Verrificamos la configuraci\u00f3n de Nginx con <code>sudo nginx -t</code> y lo reiniciamos con <code>sudo systemctl restart nginx</code>. </p> <p>Lo \u00faltimo es probar los cambios, para ello accedemos a nuestro navegador y visitamos <code>https://usuario1.local</code> y <code>https://usuario2.local</code>. Al ser un certificado autofirmado, al entrar en la p\u00e1gina nos aparecer\u00e1 la siguiente pantalla, donde necesitaremos aceptar los riesgos para poder acceder.  </p> <p>Y ya podriamos ver el contenido. </p> <p>Si queremos ver el certificado, clicamos en el candado que aparece al lado de la url y veremos la informaci\u00f3n. </p>"},{"location":"practica2-1/","title":"Practica 2.1 - Instalaci\u00f3n y configuraci\u00f3n de un servidor web Nginx","text":""},{"location":"practica2-1/#1-instalacion-servidor","title":"1.- Instalaci\u00f3n servidor","text":"<p>Para instalar el servidor de NGINX en nuestra m\u00e1quina Debian, lo primero que tendremos que hacer es actualizar los repositorios con: <code>sudo apt update</code></p> <p> Despu\u00e9s lo que tenemos que hacer es instalar el paquete correspondiente para instalar nginx: <code>sudo apt install nginx</code></p> <p> Cuando estemos en el proceso de instalaci\u00f3n aparecer\u00e1 un mensaje de '\u00bfDesea continuar? [S/n]', en el cu\u00e1l le deberemos decir que s\u00ed.</p> <p>Ahora tendremos que comprobar que nginx se ha instalado y este funcionando correctamente con el comando: <code>systemctl status nginx</code></p> <p>  Si todo est\u00e1 correcto, veremos un mensaje en verde: <code>active (running)</code></p>"},{"location":"practica2-1/#2-creacion-de-las-carpeta-del-sitio-web","title":"2.- Creaci\u00f3n de las carpeta del sitio web","text":"<p>Al igual que en Apache, todos los archivos que formar\u00e1n parte de un sitio web se organiza en carpetas. Normalmente, estas carpetas van dentro de la ubicaci\u00f3n <code>\\var\\www</code>. Ahora crearemos la carpeta de nuestro sitio web dentro de la ruta mencionada anteriormente con el siguiente comando:  <code>sudo mkdir -p /var/www/nombre_web/html</code></p> <ul> <li>Donde <code>nombre_web</code> pondremos el nombre que queremos del sitio web sin espacios.</li> </ul> <p></p> <p>Ahora accedemos a esa carpeta:</p> <p></p> <p>Dentro de esa carpeta, deberemos clonar el siguiente repositorio de github: <code>https://github.com/cloudacademy/static-website-example</code>, en caso de no tener git instalado lo instalamos con <code>sudo apt install git</code>. </p> <p></p> <p>Ahora clonamos el repositorio con el comando <code>sudo git clone https://github.com/cloudacademy/static-website-example</code>.</p> <p></p> <p>Adem\u00e1s, haremos que el propietario de los datos de esa carpeta sea del usuario www-data, que normalmente es el usuario del servicio web. <code>sudo chown -R www-data:www-data /var/www/nombre_web/html</code>.</p> <p></p> <p>Y le damos los permisos adecuados para que no nos de un error de acceso no autorizado al entrar en el sitio web con <code>sudo chmod -R 755 /var/www/nombre_web</code>.</p> <p></p> <p>Ahora comprobamos que el servidor este funcionando y sirviendo p\u00e1ginas correctamente, para ello accedemos desde un navegador a: <code>http://IP-maq-virtual</code>.</p> <ul> <li>Donde <code>IP-maq-virtual</code> es la direcci\u00f3n IP de tu m\u00e1quina Debian. En caso de no saber cu\u00e1l es, hacemos un <code>ip -a</code>.</li> </ul> <p></p> <p>Ahora buscamos la direcci\u00f3n en el navegador de tu m\u00e1quina f\u00edsica con <code>http://IP_maq_virtual</code> donde nos tendr\u00e1 que aparecer la siguiente ventana:</p> <p></p> <p>Esto significa que de momento todo esta funcionando correctamente.</p>"},{"location":"practica2-1/#3-configuracion-de-servidor-web-nginx","title":"3.- Configuraci\u00f3n de servidor web NGINX","text":"<p>En Nginx hay dos rutas importantes. La primera es <code>sites-available</code>, que es donde se almacenan los archivos de configuraci\u00f3n de los host virtuales. Es decir, cada uno de los sitios web que est\u00e1 almacenado en el servidor.</p> <p>Por otro lado, est\u00e1 <code>sites-enabled</code>, que contiene los archivos que almacenan la configuraci\u00f3n de los sitios web que est\u00e1n habilitados.</p> <p>Por defecto, hay un archivo de configuraci\u00f3n dentro de <code>sites-available</code>, que es la p\u00e1gina web que hemos visto en el anterior paso.</p> <p>Para mostrar el contenido de nuetra web, debemos crear un bloque nuevo, para ello, crearemos un nuevo fichero de configuraci\u00f3n en la ruta y con el comando siguiente:  <code>sudo nano /etc/nginx/sites-available/tu_dominio</code></p> <p></p> <p>Y se nos abrir\u00e1 esta ventana completamente vac\u00eda </p> <p></p> <p>Dentro tendremos que poner este contenido para configurarlo correctamente:</p> <pre><code>server {\n\n        listen 80;\n        listen [::]:80;\n        root /ruta/absoluta/archivo/index;\n        index index.html index.htm index.nginx-debian.html;\n        server_name nombre_web;\n        location / {\n                try_files $uri $uri/ =404;\n        }\n}\n</code></pre> <p></p> <p>Para guardar los cambios hacemos <code>Ctrl + O</code> y despu\u00e9s <code>Ctrl + X</code> para salir.</p> <p>Ahora crearemos un archivo simb\u00f3lico entre el archivo que acabamos de crear y el de sitios habilitados, para que as\u00ed, se de de alta autom\u00e1ticamente, para ello utilizaremos el siguiente comando:  <code>sudo ln -s /etc/nginx/sites-available/nombre_web /etc/nginx/sites-enabled/</code>, donde:</p> <ul> <li><code>nombre_web</code>, es el nombre que le dimos anteriormente al servidor.</li> </ul> <p></p> <p>Por \u00faltimo, reiniciamos el servidor de nginx para que la configuraci\u00f3n se aplique correctamente con: <code>sudo systemctl restart nginx</code>.</p> <p>Si no aparece ning\u00fan mensaje de error es que esta todo funcionando correctamente:</p> <p></p> <p>Por seguridad, para comprobar que el servidor esta activo, ponemos <code>sudo systemctl status nginx</code>.</p> <p></p> <p>Si todo est\u00e1 bien aparecera un mensaje en verde de: <code>active (running)</code></p>"},{"location":"practica2-1/#4-comprobaciones","title":"4.- Comprobaciones","text":"<p>Como a\u00fan no tenemos un servidor DNS que traduzca las IPs a nombres, deberemos hacerlo de forma manual editando nuestro archivo <code>/etc/hosts</code> de nuestra m\u00e1quina f\u00edsica para que as\u00ed asocie la IP de la m\u00e1quina virtual a nuestro nombre del server.</p> <p>En caso de estar en Linux, modificaremos el archivo: <code>/etc/hosts</code>.</p> <p>Y en Windows: <code>C:\\Windows\\System32\\drivers\\etc\\hosts</code>.</p> <p>En esa l\u00ednea a\u00f1adimos la direcci\u00f3n IP junto al nombre de nuestro servidor, de la siguiente manera: <code>192.168.X.X nombre_web</code>;</p> <p>En caso de no saber la direci\u00f3n IP de vuestro servidor, ponemos en la terminal de nuestra m\u00e1quina Debian <code>ip a</code>.</p> <p></p> <p>Ahora, a\u00f1adimos una l\u00ednea con lo mencionado anteriormente.</p> <p></p>"},{"location":"practica2-1/#5-ftp","title":"5.- FTP","text":"<p>En caso de querer tener varios sitios webs en el mismo servidor de nginx, tendremos que repetir todos los pasos anteriores con el nuevo nombre de dominio.</p>"},{"location":"practica2-1/#51-configurar-servidor-sftp-en-debian","title":"5.1.- Configurar servidor SFTP en Debian","text":"<p>En primer lugar, lo instalaremos desde los repositorios con estos comandos:</p> <p><code>sudo apt-get update &amp;&amp; sudo apt-get install vsftpd</code></p> <p></p> <p>Ahora creamos una carpeta en nuestro home de Debian con:  <code>mkdir /home/nombre_usuario/ftp</code>, donde:</p> <ul> <li><code>nombre_usuario</code> es el nombre del usuario en la m\u00e1quina virtual.</li> </ul> <p></p> <p>Ahora creamos un certificados de seguridad necesario para aportar la capa de cifrado de nuestra conexi\u00f3n a trav\u00e9s del comando: <code>sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout /etc/ssl/private/vsftpd.pem -out /etc/ssl/private/vsftpd.pem</code></p> <p></p> <p>Una vez puesto este comando, nos empezar\u00e1n a hacer distintas preguntas, las cuales podemos dejar en blanco o responder, en mi caso las dejo en blanco.</p> <p></p> <p>Una vez realizado este paso, configuraremos el archivo de configuraci\u00f3n de vsftpd con el comando: <code>sudo nano /etc/vsftpd.conf</code>.</p> <p>Primero buscamos estas l\u00edneas, las cuales tendremos que eliminar:</p> <pre><code>rsa_cert_file=/etc/ssl/certs/ssl-cert-snakeoil.pem\nrsa_private_key_file=/etc/ssl/private/ssl-cert-snakeoil.key\nssl_enable=NO\n</code></pre> <p></p> <p>Y ponemos lo siguiente: </p> <pre><code>rsa_cert_file=/etc/ssl/private/vsftpd.pem\nrsa_private_key_file=/etc/ssl/private/vsftpd.pem\nssl_enable=YES\nallow_anon_ssl=NO\nforce_local_data_ssl=YES\nforce_local_logins_ssl=YES\nssl_tlsv1=YES\nssl_sslv2=NO\nssl_sslv3=NO\nrequire_ssl_reuse=NO\nssl_ciphers=HIGH\n\nlocal_root=/home/nombre_usuario/ftp\n</code></pre> <p></p> <p>Cuando guardemos los cambios, reiniciamos el servicio para que la nueva configuraci\u00f3n se habilite: <code>sudo systemctl restart --now vsftpd</code>. Si todo va bien, no nos aparecer\u00e1 ning\u00fan mensaje:</p> <p></p> <p>Tras acabar la configuraci\u00f3n, podremos acceder a nuestro servidor mediante un cliente de FTP, en mi caso ser\u00e1 Filezilla, el cu\u00e1l podemos descargar en nuestra m\u00e1quina f\u00edsica a trav\u00e9s de este enlace: FileZilla. </p> <p></p> <p>Cuando termine el proceso de instalaci\u00f3n, iniciamos la aplicacion y nos encontraremos con la siguiente ventana:</p> <p></p> <p>Deberemos configurarlo de la siguiente manera:</p> <ul> <li>Servidor, pondremos la direcci\u00f3n IP de la m\u00e1quina Debian.</li> <li>Nombre de usuario, pondremos el nombre de usuario de Debian.</li> <li>Contrase\u00f1a, pondremos la contrase\u00f1a del usuario</li> <li>Puerto, ser\u00e1 el 21 para conectarnos usando los certificados que hemos generado antes.   Quedar\u00eda de la siguiente manera:</li> </ul> <p></p> <p>Ahora damos clic en <code>Conexi\u00f3n r\u00e1pida</code> y nos saltar\u00e1 un aviso a prop\u00f3sito del certificado, pulsamos en aceptar ya que este peligro lo hemos generado nosotros mismos:</p> <p></p> <p>Una vez que ya estemos conectados, buscaremos en la secci\u00f3n izquierda de la pantalla la carpeta donde tengamos el <code>.zip</code> y en la parte derecha seleccionaremos la carpeta donde queremos subirla, haciendo doble click o utilizando el <code>bot\u00f3n derecho &gt; subir</code>.</p> <p></p> <p>Otra opci\u00f3n es conectarnos mediante SFTP, que para ello tendriamos que:</p> <ul> <li>En servidor pondremos: <code>sftp://direcci\u00f3n_ip</code></li> <li>Quitaremos la contrase\u00f1a.</li> <li>Pondremos el puerto 22.</li> </ul> <p>Quedar\u00eda de la siguiente manera:</p> <p></p> <p>Hacemos click en <code>Conexi\u00f3n r\u00e1pida</code> y empezar\u00e1 a conectarnos con el servidor Debian. Devido a que estamos usando claves FTP para conectarnos, nos aparecer\u00e1 un aviso parecido al que nos sal\u00eda al conectarnos por primera vez por SSH a nuestra Debian, que aceptamos porque sabemos que no entra\u00f1a ning\u00fan peligro en este caso:</p> <p></p> <p>Aqu\u00ed nos conecta al <code>/home</code> del usuario, en vez de al <code>ftp</code>. Como vemos si accedemos al directorio <code>/ftp</code>, aparece el archivo que hemos subido anteriormente.</p> <p></p> <p>Ahora vamos a descomprimir el archivo desde nuestra m\u00e1quina Debian, para ello usamos el comando: <code>unzip nombre_archivo.zip -d /nombre/directorio</code>.</p> <p></p> <p>Una vez ese paso est\u00e1 completado, veremos que el archivo se encuentra en el directorio donde lo hab\u00edamos descomprimido, que en mi caso es en el escritorio.</p> <p></p>"},{"location":"practica2-1/#6-https","title":"6.- HTTPS","text":"<p>En este apartado le a\u00f1adiremos a nuestro servidor una capa de seguridad necesaria por seguridad. Haremos que todos nuestros sitios web alojados hagan uso de certificados SSL y se acceda a ellos por medio de HTTPS.</p> <p>El primer paso ser\u00e1 generar un Certificado SSL, para ello usaremos el comando: <code>sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout /etc/ssl/private/nginx-selfsigned.key -out /etc/ssl/certs/nginx-selfsigned.crt</code> </p> <p>Nos pedir\u00e1 una serie de datos las cuales podemos dejar en blanco:</p> <p></p> <p>Ahora tendremos que configurar el fichero <code>/etc/nginx/sites-available/nombre_dominio</code>, a trav\u00e9s de <code>sudo nano</code> y pondremos lo siguiente:</p> <p></p> <p>Guardamos los cambios con <code>Ctrl + O</code> y salimos con <code>Ctrl + X</code>.</p> <p>Tras eso comprobamos que la sintaxis est\u00e9 bien con <code>sudo nginx -t</code>, si no hay problemas aparecer\u00e1 un mensaje de <code>syntax is ok</code>:</p> <p></p> <p>Ahora reiniciamos nuestro servidor de nginx para que se activen los cambios con <code>sudo systemctl restart nginx</code>. Si todo va bien no aparecer\u00e1 ning\u00fan mensaje de error:</p> <p></p> <p>Y en nuestra m\u00e1quina a\u00f1adimos la direcci\u00f3n ip de la m\u00e1quina Debian:</p> <p></p> <p>Y ya podemos acceder en nuestro navegador a la direcci\u00f3n y veremos la siguiente ventana:</p> <p></p>"},{"location":"practica2-1/#7-cuestiones-finales","title":"7.- Cuestiones finales","text":""},{"location":"practica2-1/#cuestion-1-que-pasa-si-no-hago-el-link-simbolico-entre-sites-available-y-sites-enabled-de-mi-sitio-web","title":"Cuesti\u00f3n 1: \u00bfQu\u00e9 pasa si no hago el link simb\u00f3lico entre <code>sites-available</code> y <code>sites-enabled</code> de mi sitio web?","text":"<p>Si no hacemos el enlace el stio web no ser\u00e1 visible, ya que el archivo que habilita los servidores web es <code>sites-enabled</code></p>"},{"location":"practica2-1/#cuestion-2-que-pasa-si-no-le-doy-los-permisos-adecuados-a-varwwwnombre_web","title":"Cuesti\u00f3n 2: \u00bfQu\u00e9 pasa si no le doy los permisos adecuados a <code>/var/www/nombre_web</code>?","text":"<p>Si no le damos los permisos adecuados, lo m\u00e1s probable es que ocurran problemas a la hora de intentar acceder al sitio web, ya que si no tenemos permisos de lectura y en algunos casos de ejecuci\u00f3n de archivos y directorios, podemos encontrarnos con errores a la hora de acceder como:</p> <ul> <li><code>403 Forbidden</code>, que ocurre cuando el servidor no tiene permiso para acceder al directorio.</li> </ul>"},{"location":"practica2-2/","title":"Pr\u00e1ctica 2.2 - Autenticaci\u00f3n en Nginx","text":""},{"location":"practica2-2/#paquetes-necesarios","title":"Paquetes necesarios","text":"<p>En primer lugar vemos si tenemos instalado el paquete necesario para hacer autenticaciones:  <code>dpkg -l | grep openssl</code></p> <p> Si no lo tenemos instalados, tendriamos que hacerlo.</p>"},{"location":"practica2-2/#1-creacion-de-usuarios-y-contrasenas-para-el-acceso-web","title":"1.- Creaci\u00f3n de usuarios y contrase\u00f1as para el acceso web","text":"<p>Creamos un archivo oculto llamado <code>.httpasswd</code> en el directorio de configuraci\u00f3n del servidor <code>/etc/nginx</code> donde guardaremos nuestros usuarios y contrase\u00f1as: </p> <p><code>sudo sh -c \"echo -n 'vuestro_nombre:' &gt;&gt; /etc/nginx/.htpasswd\"</code></p> <p>Y ahora creamos la contrase\u00f1a cifrada para el usuario: <code>sudo sh -c \"openssl passwd -apr1 &gt;&gt; /etc/nginx/.htpasswd\"</code> Justo al poner el comando, nos pedir\u00e1 que introduzcamos la contrase\u00f1a.</p> <p> Por cada usuario que queramos crear tenemos que seguir estos dos pasos.</p> <p>Ahora, crearemos dos usuarios, uno con tu nombre y otro con tu primer apellido:</p> <ul> <li> <p>Usuario 1:   </p> </li> <li> <p>Usuario 2:   </p> </li> </ul> <p>Ahora comprobamos que se han creado correctamente con <code>cat /etc/nginx/.htpasswd</code>:</p> <p></p>"},{"location":"practica2-2/#2-configurando-el-servidor-nginx-para-usar-autenticacion-basica","title":"2.- Configurando el servidor Nginx para usar autenticaci\u00f3n b\u00e1sica","text":"<p>Para configurar el acesso al servidor web con autenticaci\u00f3n, editaremos nuestro archivo donde se almacena el sitio con <code>sudo nano /etc/nginx/sites-available/nombre_web</code>. Donde nombre_web es el nombre que le pusiste a tu servidor web anteriormente.\u00b4</p> <p></p> <p>En <code>location</code> a\u00f1adiremos dos nuevas l\u00edneas:</p> <ul> <li><code>auth_basic</code>, le pondremos el nombre a nuestro dominio que ser\u00e1 mostrado al usuario al solicitar las credenciales.</li> <li><code>auth_basic_user_file</code>, para que utilice el fichero que previamente hemos creado con los usuarios y sus respectivas contrase\u00f1as.</li> </ul> <p> Una vez realizados esos cambios, reiniciamos el servicio para que aplique la configuraci\u00f3n de acceso: <code>sudo systemctl restart nginx</code>.</p> <p> Si todo va bien, no aparecer\u00e1 ning\u00fan mensaje.</p>"},{"location":"practica2-2/#3-probando-la-nueva-configuracion","title":"3.- Probando la nueva configuraci\u00f3n","text":""},{"location":"practica2-2/#comprobacion-1-comprueba-desde-tu-maquina-fisicaanfitrion-que-puedes-acceder-a-httpnombre-sitio-web-y-que-se-te-solicita-autenticacion","title":"Comprobaci\u00f3n 1: Comprueba desde tu m\u00e1quina f\u00edsica/anfitri\u00f3n que puedes acceder a <code>http://nombre-sitio-web</code> y que se te solicita autenticaci\u00f3n.","text":""},{"location":"practica2-2/#comprobacion-2-comprueba-que-si-decides-cancelar-la-autenticacion-se-te-negara-el-acceso-al-sitio-con-un-error-que-error-es","title":"Comprobaci\u00f3n 2: Comprueba que si decides cancelar la autenticaci\u00f3n, se te negar\u00e1 el acceso al sitio con un error. \u00bfQu\u00e9 error es?","text":"<p>Error 401: Authorization Required. </p>"},{"location":"practica2-2/#tareas","title":"Tareas","text":""},{"location":"practica2-2/#tarea-1-intenta-entrar-primero-con-un-usuario-erroneo-y-luego-con-otro-correcto-puedes-ver-todos-los-sucesos-y-registros-en-los-logs-accesslog-y-errorlog-adjunta-una-captura-de-pantalla-de-los-logs-donde-se-vea-que-intentas-entrar-primero-con-un-usuario-invalido-y-con-otro-valido-indica-donde-podemos-ver-los-errores-de-usuario-invalido-o-no-encontrado-asi-como-donde-podemos-ver-el-numero-de-error-que-os-aparecia-antes","title":"Tarea 1.- Intenta entrar primero con un usuario err\u00f3neo y luego con otro correcto. Puedes ver todos los sucesos y registros en los logs access.log y error.log  Adjunta una captura de pantalla de los logs donde se vea que intentas entrar primero con un usuario inv\u00e1lido y con otro v\u00e1lido. Indica d\u00f3nde podemos ver los errores de usuario inv\u00e1lido o no encontrado, as\u00ed como donde podemos ver el n\u00famero de error que os aparec\u00eda antes.","text":"<p>Primero, hemos probado con el usuario <code>mario ayuso</code>, el cu\u00e1l no existe en nuestro archivo <code>.htpasswd</code>. Y despu\u00e9s con <code>alfonso ramirez</code>, que si existe en dicho fichero.</p> <p>Accedemos al registro del fichero <code>error.log</code>, para comprobar que se ha guardado el registro del usuario que no existe intentando acceder con el comando: <code>sudo nano /var/log/nginx/error.log</code>.  Como podemos ver, el \u00faltimo mensaje es de ese usuario intentando acceder al servidor web <code>aramirez.com</code> provocando un error.</p> <p>Ahora accedemos al fichero <code>access.log</code> para comprobar los accesos de los distintos usuarios con <code>sudo nano /var/log/nginx/access.log</code>.</p> <p></p> <p>En primer lugar, encontramos el usuario inexistente <code>mario ayuso</code> que ha tenido un Error 401 y seguidamente el usuario correcto <code>alfonso ramirez</code>, que vemos que ha tenido un c\u00f3digo 200, es decir, se conecto existosamente.</p>"},{"location":"practica2-2/#tarea-2-borra-las-dos-lineas-que-hacen-referencia-a-la-autenticacion-basica-en-el-location-del-directorio-raiz-tras-ello-anade-un-nuevo-location-debajo-con-la-autenticacion-basica-para-el-archivoseccion-contacthtml-unicamente","title":"Tarea 2.- Borra las dos l\u00edneas que hacen referencia a la autenticaci\u00f3n b\u00e1sica en el location del directorio ra\u00edz. Tras ello, a\u00f1ade un nuevo location debajo con la autenticaci\u00f3n b\u00e1sica para el archivo/secci\u00f3n contact.html \u00fanicamente.","text":"<p>Debido a que la web que estamos utilizandos solo cuenta con un fichero index.html, duplicaremos este fichero renombrandolo como contact.html de la siguiente manera:  <code>sudo cp /var/www/aramirez/index.html /var/www/aramirez/contact.html</code>: </p> <p>El siguiente paso ser\u00e1 modificar el archivo del sitio web con <code>sudo nano /etc/nginx/sites-available/aramirez</code>. </p> <p>Encontraremos esta configuraci\u00f3n y quitamos las opciones de autorizaci\u00f3n de <code>location /</code> y creamos otro que sea: <code>location /contact.html</code> con la siguiente estructura:</p> <p> Guardamos la configuraci\u00f3n con <code>Ctrl + O</code> y salimos con <code>Ctrl + X</code>.</p> <p>Ahora reiniciamos el servidor de nginx con <code>sudo systemctl restart nginx</code> </p> <p>Por \u00faltimo, desde nuestra m\u00e1quina f\u00edsica accedemos al sitio web <code>nombre_sitio/contact.html</code>, donde:</p> <ul> <li><code>nombre_sitio</code>, es el nombre de nuestro sitio, que en mi caso es <code>aramirez</code>. Nos deberiamos encontrar con lo siguiente:   </li> </ul>"},{"location":"practica2-2/#31-combinacion-de-la-autenticacion-basica-con-la-restriccion-de-acceso-por-ip","title":"3.1.- Combinaci\u00f3n de la autenticaci\u00f3n b\u00e1sica con la restricci\u00f3n de acceso por IP","text":"<p>La autenticaci\u00f3n b\u00e1sica HTTP puede ser combinada de forma efectiva con la restricci\u00f3n de acceso por direcci\u00f3n IP. Se puede implementar dos escenarios:</p> <ul> <li>Un usuario debe estar autenticado y tener una IP v\u00e1lida.</li> <li>Un usuario debe de estar autenticado o tener una IP v\u00e1lida.</li> </ul> <p>Se har\u00eda de la siguiente forma:</p> <ol> <li>Permitir o denegar acceso sobre una IP concreta (allows y deny, respectivamente). Dentro del archivo de configuraci\u00f3n de <code>sites-available</code>, que para modificarlo usamos el comando: <code>sudo nano /etc/nginx/sites-available/aramirez</code>. </li> </ol> <p>Dentro del archivo pondremos algo as\u00ed:  Guardamos los cambios con <code>Ctrl + O</code> y salimos con <code>Ctrl + X</code>.</p> <p>El acceso se garantizar\u00e1 a todas las IPs de <code>192.168.1.1/24</code>, excluyendo la direcci\u00f3n <code>192.168.1.119</code> (la de mi ordenador) y denegaremos el acceso a todo el mundo restante con <code>deny all</code>.</p> <p>Ahora probaremos que nos ha bloqueado el acceso, pero primero, reiniciamos el servidor de nginx con <code>sudo systemctl restart nginx</code>: </p> <p>Importante Hay que tener en cuenta que estas directivas se aplican en orden en el que se aparecen en el archivo.</p> <ol> <li>Combinar la restricci\u00f3n IP y la autenticaci\u00f3n con la directiva safely</li> </ol> <p>Si a\u00f1adimos la directiva <code>satisfy all</code>, el acceso se permite si el cliente cumple ambas condiciones (Ip y usuario). Si a\u00f1adimos la directiva <code>satisfy any</code>, permite el acceso si se cumple al menos una de las dos condiciones, por ejemplo: </p>"},{"location":"practica2-2/#tareas_1","title":"Tareas","text":""},{"location":"practica2-2/#tarea-1-configura-nginx-para-que-no-deje-acceder-con-la-ip-de-la-maquina-anfitriona-al-directorio-raiz-de-una-de-tus-dos-webs-modifica-su-server-block-o-archivo-de-configuracion-comprueba-como-se-deniega-el-acceso","title":"Tarea 1.- Configura Nginx para que no deje acceder con la IP de la m\u00e1quina anfitriona al directorio ra\u00edz de una de tus dos webs. Modifica su server block o archivo de configuraci\u00f3n. Comprueba como se deniega el acceso:","text":"<p>Y como podemos ver al acceder al sitio web, nos aparecer\u00e1 el mensaje 403 Forbidden, que eso quiere decir que no tenemos acceso permitido, que era lo que queriamos comprobar. </p> <p>Ahora comprobamos el archivo <code>error.log</code>: </p>"},{"location":"practica2-2/#tarea-2-configura-nginx-para-que-desde-tu-maquina-anfitriona-se-tenga-que-tener-tanto-una-ip-valida-como-un-usuario-valido-ambas-cosas-a-la-vez-y-comprueba-que-si-puede-acceder-sin-problemas","title":"Tarea 2.- Configura Nginx para que desde tu m\u00e1quina anfitriona se tenga que tener tanto una IP v\u00e1lida como un usuario v\u00e1lido, ambas cosas a la vez, y comprueba que s\u00ed puede acceder sin problemas","text":"<p>Ahora accedemos desde mi m\u00e1quina anfitriona: </p> <p>Como vemos nos pide autoizaci\u00f3n, cuando introduzcamos un usuario v\u00e1lido veremos la siguiente pantalla: </p>"},{"location":"practica2-2/#cuestiones-finales","title":"Cuestiones Finales","text":""},{"location":"practica2-2/#cuestion-1-supongamos-que-yo-soy-el-cliente-con-la-ip-17211015-e-intento-acceder-al-directorio-web_muy_guay-de-mi-sitio-web-equivocandome-al-poner-el-usuario-y-contrasena-podre-acceder-por-que","title":"Cuesti\u00f3n 1.- Supongamos que yo soy el cliente con la IP 172.1.10.15 e intento acceder al directorio web_muy_guay de mi sitio web, equivoc\u00e1ndome al poner el usuario y contrase\u00f1a. \u00bfPodr\u00e9 acceder? \u00bfPor qu\u00e9?","text":"<pre><code>location /web_muy_guay {\n  #...\n  satisfy all;\n  deny 172.1.10.6;\n  allow 172.1.10.15;\n  allow 172.1.3.14;\n  deny all;\n  auth_basic \"Cuesti\u00f3n final 1\";\n  auth_basic_user_file conf/htpasswd;\n}\n</code></pre> <p>No podr\u00e1s acceder ya que a pesar de que tu direcci\u00f3n IP est\u00e9 incluida en la lista de IPs permitidas, si te equivocas al introducir tu usuario y contrase\u00f1a, existe la directiva de <code>satisfy all</code>, que significa que tanto la autenticaci\u00f3n debe ser correcta y la IP debe tener permitido su acceso.</p>"},{"location":"practica2-2/#cuestion-2-supongamos-que-yo-soy-el-cliente-con-la-ip-17211015-e-intento-acceder-al-directorio-web_muy_guay-de-mi-sitio-web-introduciendo-correctamente-usuario-y-contrasena-podre-acceder-por-que","title":"Cuesti\u00f3n 2.- Supongamos que yo soy el cliente con la IP 172.1.10.15 e intento acceder al directorio web_muy_guay de mi sitio web, introduciendo correctamente usuario y contrase\u00f1a. \u00bfPodr\u00e9 acceder? \u00bfPor qu\u00e9?","text":"<pre><code>    location /web_muy_guay {\n    #...\n    satisfy all;\n    deny  all;\n    deny  172.1.10.6;\n    allow 172.1.10.15;\n    allow 172.1.3.14;\n\n    auth_basic \"Cuesti\u00f3n final 2: The revenge\";\n    auth_basic_user_file conf/htpasswd;\n\n}\n</code></pre> <p>No, ya que aunque tanto la direcci\u00f3n IP como las credenciales esten permitida y sean correctas respectivamente, el orden de las directivas de nginx son muy importantes y antes de permitir las direcciones IP, est\u00e1 denegandolas todas.</p>"},{"location":"practica2-2/#cuestion-3-supongamos-que-yo-soy-el-cliente-con-la-ip-17211015-e-intento-acceder-al-directorio-web_muy_guay-de-mi-sitio-web-introduciendo-correctamente-usuario-y-contrasena-podre-acceder-por-que","title":"Cuesti\u00f3n 3.- Supongamos que yo soy el cliente con la IP 172.1.10.15 e intento acceder al directorio web_muy_guay de mi sitio web, introduciendo correctamente usuario y contrase\u00f1a. \u00bfPodr\u00e9 acceder? \u00bfPor qu\u00e9?","text":"<pre><code>    location /web_muy_guay {\n    #...\n    satisfy any;\n    deny  172.1.10.6;\n    deny 172.1.10.15;\n    allow 172.1.3.14;\n\n    auth_basic \"Cuesti\u00f3n final 3: The final combat\";\n    auth_basic_user_file conf/htpasswd;\n\n}\n</code></pre> <p>No, ya que con <code>**satisfy any**</code>, cualquiera de las condiciones que se cumpla permitir\u00eda el acceso a la web, pero en este caso no, ya que la direcci\u00f3n IP del cliente se encuentra con el acceso denegado y es prioritaria respecto a la autenticaci\u00f3n.</p>"},{"location":"practica2-2/#cuestion-4-a-lo-mejor-no-sabeis-que-tengo-una-web-para-documentar-todas-mis-excursiones-espaciales-con-jeff-es-esta-jeff-bezos-y-yosupongamos-que-quiero-restringir-el-acceso-al-directorio-de-proyectos-porque-es-muy-secreto-eso-quiere-decir-anadir-autenticacion-basica-a-la-urlproyectoscompleta-la-configuracion-para-conseguirlo","title":"Cuesti\u00f3n 4.- A lo mejor no sab\u00e9is que tengo una web para documentar todas mis excursiones espaciales con Jeff, es esta: Jeff Bezos y yoSupongamos que quiero restringir el acceso al directorio de proyectos porque es muy secreto, eso quiere decir a\u00f1adir autenticaci\u00f3n b\u00e1sica a la URL:ProyectosCompleta la configuraci\u00f3n para conseguirlo:","text":"<pre><code>    server {\n        listen 80;\n        listen [::]:80;\n        root /var/www/freewebsitetemplates.com/preview/space-science;\n        index index.html index.htm index.nginx-debian.html;\n        server_name freewebsitetemplates.com www.freewebsitetemplates.com;\n        location              {\n\n            try_files $uri $uri/ =404;\n        }\n    }\n</code></pre> <p>Tendriamos que a\u00f1adir en <code>location</code> las siguientes l\u00edneas:</p> <pre><code>location /projects.html {\n      auth_basic \"Accediendo a proyectos\";\n      auth_basic_user_file conf/.htpasswd;\n}\n</code></pre>"},{"location":"practica2-3/","title":"Pr\u00e1ctica 2.3.- Proxy inverso con Nginx","text":""},{"location":"practica2-3/#1-configuracion-nginx","title":"1. Configuraci\u00f3n Nginx","text":""},{"location":"practica2-3/#11-servidor-web","title":"1.1.- Servidor web","text":"<p>El primer paso para la realizaci\u00f3n de esta pr\u00e1ctica es clonar la m\u00e1quina Debian en la que tenemos instalado nuestro servidor de Nginx.</p> <ul> <li>Un servidor servir\u00e1 los sitios webs que ya hemos configurado anteriormente.</li> <li>El nuevo servidor estar\u00e1 configurado como <code>proxy inverso</code>.</li> <li>Realizaremos las peticiones HTTP desde nuestra m\u00e1quina f\u00edsica hacia el proxy clonado, que este nos redigir\u00e1 hasta el servidor web original.</li> </ul> <p>IMPORTANTE A la hora de clonar la m\u00e1quina es importante <code>Generar nuevas direcciones MAC</code>, para poder comunicarnos entre las m\u00e1quinas.  Despu\u00e9s de clonar la m\u00e1quina, la iniciaremos y haremos los siguientes cambios.</p> <ol> <li> <p>Cambiar el nombre de nuestra web por <code>webserver</code>, esto implica estos cambios:</p> </li> <li> <p>Cambiar el nombre del archivo de configuraci\u00f3n de sitios disponibles en Nginx, para ello usamos <code>sudo mv /etc/nginx/sites-available/nombre_servidor /etc/nginx/sites-available/webserver</code>.      Tras esto, accederemos al fichero de configuraci\u00f3n con <code>sudo nano /etc/nginx/sites-available/webserver</code> para seguir realizando cambios.   </p> </li> <li> <p>Eliminamos el enlace simb\u00f3lico con el comando <code>unlink nombre_del_link</code> dentro de la carpeta <code>sites_enabled</code> y creamos el nuevo enlace para el nuevo nombre de archivo con <code>sudo ln /etc/nginx/sites-available/webserver /etc/nginx/sites-enabled/</code>.   </p> </li> <li> <p>Ahora volvemos a configurar el archivo de configuraci\u00f3n y cambiamos el puerto de escucha del <code>80</code> al <code>8080</code>.     </p> </li> <li> <p>Reiniciamos Nginx con <code>sudo systemctl restart nginx</code>, si no aparece ning\u00fan mensaje significa que la configuraci\u00f3n esta correcta.     </p> </li> </ol>"},{"location":"practica2-3/#12-proxy-inverso","title":"1.2.- Proxy inverso","text":"<p>Iniciamos nuestra otra m\u00e1quina Debian, es decir, donde configuraremos el proxy. Para ello creamos un archivo de configuraci\u00f3n en <code>sites-available</code> con el nombre <code>ejemplo_proxy</code> con <code>sudo nano /etc/nginx/sites-available/ejemplo_proxy</code> </p> <p>Y ponemos la siguiente configuraci\u00f3n: </p> <ul> <li>En <code>listen</code>, ponemos el puerto que queremos escuchar.</li> <li>En <code>server_name</code>, ponemos el nombre de nuestro dominio al que queremos acceder en el proxy.</li> <li>En <code>proxy_pass</code>, ponemos la direcci\u00f3n IP de la m\u00e1quina que tiene alojada el servidor y el puerto al que queremos reenviar.</li> <li>Por \u00faltimo creamos un link simb\u00f3lico con: <code>sudo ln /etc/nginx/sites-available/ejemplo-proxy /etc/nginx/sites-enabled/</code> </li> </ul>"},{"location":"practica2-3/#2-comprobaciones","title":"2.- Comprobaciones","text":"<p>Editamos nuestro fichero <code>hosts</code> para a\u00f1adir el sitio <code>ejemplo-proxy.com</code>: </p> <p>Y ahora accedemos a nuestro sitio web mediante <code>ejemplo-proxy.com</code>, donde si todo va bien nos preguntar\u00e1 nuestro usuario y contrase\u00f1a como en anteriores pr\u00e1cticas: </p> <p>Y accedemos a la consola mediante la tecla F12, al apartado de red y vemos lo siguiente: </p> <p>Aqu\u00ed vemos que la respuesta de la petici\u00f3n es un c\u00f3digo <code>200 OK</code>, tambi\u00e9n vemos las cabeceras que se incluyen en la petici\u00f3n del m\u00e9todo GET y en la respuesta de la petici\u00f3n.</p> <p>Ahora comprobamos los access.log en los dos servidores: EJEMPLO_PROXY </p> <p>WebServer </p>"},{"location":"practica2-3/#3-anadiendo-cabeceras","title":"3.- A\u00f1adiendo cabeceras","text":"<p>Adem\u00e1s de haber mirado los logs, vamos a demostrar a\u00fan de forma m\u00e1s clara que la petici\u00f3n est\u00e1 pasando por el proxy inverso y que est\u00e1 llegando al servidor web y que vuelve por el mismo camino.</p> <p>Para ello, a\u00f1adiremos una cabecera en el fichero de configuraci\u00f3n del Proxy inverso dentro de <code>location / {...}</code> a\u00f1adimos esta directiva: <code>add_header Host nombre_del_host</code>, quedar\u00eda as\u00ed: </p> <p>El siguiente paso ser\u00e1 reiniciar nginx: </p> <p>Ahora comprobamos que podemos acceder al sitio web sin problemas y buscamos que el proxy inverso ha a\u00f1adido la cabecera a la respuesta: </p> <p>Y ahora hacemos el mismo paso en nuestro WebServer. Si todo esta correcto, aparecer\u00e1n ambas cabeceras. </p> <p>IMPORTANTE Para realizar estas comprobaciones es imprescindible tener marcado el checkbox de <code>Desactivar cach\u00e9</code>, ya que si no se marca esta opci\u00f3n la p\u00e1gina se guardar\u00e1 en la memoria cach\u00e9 del navegador y no recibir\u00e9is la respuesta del servidor. </p>"},{"location":"practica2-4/","title":"Pr\u00e1ctica 2.4.- Balanceo de carga con proxy inverso en Nginx","text":""},{"location":"practica2-4/#1-que-es-un-balanceador-de-carga","title":"1.- \u00bfQu\u00e9 es un balanceador de carga?","text":"<p>Un balanceador de carga distribuye las solicitudes entrantes del cliente entre un grupo de servidores, en cada caso devuelve la respuesta del servidor seleccionado al cliente apropiado.</p>"},{"location":"practica2-4/#2-tarea","title":"2.- Tarea","text":"<p>El primer paso ser\u00e1 configurar dos servidores web Nginx con dos m\u00e1quinas Debian, adem\u00e1s de utilizar el proxy inverso Nginx que configuramos en la pr\u00e1ctica anterior. A continuaci\u00f3n, modificaremos la configuraci\u00f3n a\u00f1adiendo lo necesario:</p> <ul> <li>Cada servidor web presentar\u00e1 un sitio web espec\u00edfico.</li> <li>El <code>webserver2</code> debe tener la IP asignada de forma fija mediante DHCP.</li> <li>El <code>proxy inverso</code>, habr\u00e1 que configurarlo para que realice el balanceo ce carga.</li> <li>Realizaremos las peticiones HTTP desde el navegador de nuestra m\u00e1quina anfritiona.</li> </ul> <p>La red quedar\u00e1 de la siguiente manera: </p> <p>Las peticiones se har\u00e1n desde el navegador al proxy inverso, que este las repartir\u00e1 entre los dos servidores web.</p> <p>Accederemos a <code>http://balanceo</code> yu observaremos que las peticiones se van repartiendo entre el <code>webserver1</code> y <code>webserver2</code>.</p>"},{"location":"practica2-4/#3-configuraciones","title":"3.- Configuraciones","text":"<p>ATENCI\u00d3N! Los sitios web configurados anteriormente no se van a utilizar, por ello, recomiendo desactivarlos de la carpeta <code>/etc/nginx/sites-enabled</code> con el comando <code>unlink nombre_archivo</code>. si no se hace esto, nos dar\u00e1 error en todas las pr\u00e1cticas restantes.</p> <p>Ejemplo en webserver1 </p>"},{"location":"practica2-4/#31-nginx-webserver1","title":"3.1.- Nginx Webserver1","text":"<p>El primer servidor ser\u00e1 el servidor principal que hemos utilizado desde la primera pr\u00e1ctica, es decir, el original.</p> <p>Debemos configurar este servidor para que sirva el siguiente <code>index.html</code> que se debe crear dentro de la carpeta <code>**/var/www/webserver1/html</code>: </p> <ul> <li>El nombre del sitio web que se debe utilizar en los archivos de <code>sites-available</code> que se debe crear para Nginx es <code>webserver1</code>.</li> <li>El sitio web debe escuchar en el puerto 8080.</li> <li>Deb\u00e9is a\u00f1adir una cabecera que se llame <code>Serv_Web1_vuestronombre</code>.   </li> </ul> <p>Creamos un enlace simb\u00f3lico en <code>sites-enabled</code> y reiniciamos el servidor:   </p>"},{"location":"practica2-4/#32-nginx-webserver2","title":"3.2.- Nginx Webserver2","text":"<p>Debe ser un clon del webserver1.</p> <p>En este servidor se hace una configuraci\u00f3n id\u00e9ntica al webserver1 pero poniendo webserver2 (tambi\u00e9n en el index.html), as\u00ed como el nombre de la cabecera a\u00f1adida, que ser\u00e1 <code>Serv_Web2_vuestronombre</code>.  </p>"},{"location":"practica2-4/#33-nginx-proxy-inverso","title":"3.3.- Nginx Proxy Inverso","text":"<p>Ya disponemos de los dos webservers ahora configuraremos el proxy inverso como el balanceador de carga. </p> <p>Donde:</p> <ul> <li>En el bloque <code>upstream</code> son los servidores entre los que se va a repartir la carga.</li> <li>Le ponemos un nombre, en mi caso: <code>backend_hosts</code>;</li> </ul> <p>El \u00faltimo paso ser\u00e1 a\u00f1adir tanto en nuestra m\u00e1quina como en la que va a realizar de <code>balanceo</code> la direcci\u00f3n host de los servidores:  </p>"},{"location":"practica2-4/#4-comprobaciones","title":"4.- Comprobaciones","text":"<p>Ahora accederemos al sitio web <code>balanceo.com</code>, donde cada vez que refresquemos nos podr\u00e1 aparecer el contenido del <code>webserver1</code> o de <code>webserver2</code>.</p> <p>IMPORTANTE!! Debemos comprobar que en la consola de nuestro navegador, en el apartado de red, tenemos activada la opci\u00f3n de <code>deactivar cach\u00e9</code>: </p> <p> </p>"},{"location":"practica2-4/#41-comprobacion-de-balanceo-de-carga","title":"4.1.- Comprobaci\u00f3n de balanceo de carga","text":"<p>Ahora, comprobaremos que el balanceador funciona correctamente, para ello:</p> <ul> <li> <p>Paramos el servicio nginx del webserver1 y comprobamos que todas las solicitudes se env\u00edan al webserver2.    </p> </li> <li> <p>Ahora lo hacemos a la inversa, paramos el webserver2 y accedemos a <code>balanceo.com</code>:</p> </li> </ul> <p></p>"},{"location":"practica2-4/#5-cuestiones","title":"5.- Cuestiones","text":""},{"location":"practica2-4/#cuestion-1-busca-informacion-de-que-otros-metodos-de-balanceo-se-pueden-aplicar-con-nginx-y-describe-al-menos-3-de-ellos","title":"Cuesti\u00f3n 1.- Busca informaci\u00f3n de qu\u00e9 otros m\u00e9todos de balanceo se pueden aplicar con Nginx y describe al menos 3 de ellos.","text":"<ol> <li> <p>Least Connections: Asigna solicitudes al servidor con menos conexiones activas, evitando sobrecargar aquellos que ya est\u00e1n ocupados. Es ideal para servidores de capacidad similar y para situaciones con conexiones persistentes o largas, ya que distribuye la carga de manera eficiente seg\u00fan la disponibilidad de recursos en cada momento.</p> </li> <li> <p>IP Hash: Dirige cada cliente al mismo servidor seg\u00fan su IP, manteniendo la persistencia de sesi\u00f3n. Esto es \u00fatil cuando es importante que el usuario permanezca en el mismo servidor durante toda su sesi\u00f3n, evitando problemas de cambio de servidor.</p> </li> <li> <p>Least Time: Asigna solicitudes al servidor con el tiempo de respuesta m\u00e1s r\u00e1pido, considerando la cola de espera. Es ideal para aplicaciones de baja latencia, como servicios en tiempo real.</p> </li> </ol>"},{"location":"practica2-4/#cuestion-2-si-quiero-anadir-2-servidores-web-mas-al-balanceo-de-carga-describe-detalladamente-que-configuracion-habria-que-anadir-y-donde","title":"Cuesti\u00f3n 2.- Si quiero a\u00f1adir 2 servidores web m\u00e1s al balanceo de carga, describe detalladamente qu\u00e9 configuraci\u00f3n habr\u00eda que a\u00f1adir y d\u00f3nde.","text":"<p>Para a\u00f1adir 2 servidores m\u00e1s al balanceo de carga, deberemos editar el archivo de configuraci\u00f3n de nuestro servidor <code>balanceo</code> y definir los nuevos servidores. Despu\u00e9s, a\u00f1adimos en el fichero <code>/etc/hosts</code> las dos direcciones IP y su respectivo nombre de servidor. Por \u00faltimo, aplicamos los cambios reiniciando el servidor de nginx.</p>"},{"location":"practica2-4/#cuestion-3-describe-todos-los-pasos-que-deberiamos-seguir-y-configurar-para-realizar-el-balanceo-de-carga-con-una-de-las-webs-de-practicas-anteriores-indicad-la-configuracion-de-todas-las-maquinas-webservers-proxy-y-de-sus-servicios","title":"Cuesti\u00f3n 3.- Describe todos los pasos que deber\u00edamos seguir y configurar para realizar el balanceo de carga con una de las webs de pr\u00e1cticas anteriores. Indicad la configuraci\u00f3n de todas las m\u00e1quinas (webservers, proxy...) y de sus servicios","text":"<p>En los webservers configuraremos el <code>sites-available</code> a\u00f1adiendole cabeceras para poder identificar a cada <code>webserver</code> correctamente, modificaremos el atributo <code>server_name</code>. Respecto a la m\u00e1quina que hace de proxy, modificamos las direcciones IP en el archivo <code>/etc/hosts</code> a\u00f1adiendo la direcci\u00f3n de cada webserver con su respectivo <code>server_name</code>, adem\u00e1s, a\u00f1adiremos un bloque <code>upstream</code> en el archivo de configuraci\u00f3n donde a\u00f1adiremos los nombres de cada webserver, por \u00faltimo, el nombre de <code>proxy_pass</code> ser\u00e1 el nombre que hemos asignado en el bloque <code>upstream</code>.</p>"},{"location":"practica2-5/","title":"Pr\u00e1ctica2.5.- Proxy Inverso y Balanceo de carga con SSL en NGINX","text":""},{"location":"practica2-5/#1-introduccion","title":"1.- Introducci\u00f3n","text":"<p>En esta pr\u00e1ctica usaremos nuestro balanceador de la pr\u00e1ctica anterior y adem\u00e1s le a\u00f1adiremos cifrado SSL para mayor seguridad y as\u00ed, asegurarnos que, cuando entramos en el sitio web nos presente un c\u00e9rtificado digital para asegurarnos que es quien dice ser.</p> <p></p>"},{"location":"practica2-5/#2-tarea","title":"2.- Tarea","text":""},{"location":"practica2-5/#21-creacion-del-certificado-autofirmado","title":"2.1.- Creaci\u00f3n del certificado autofirmado","text":"<p>Para crear nuestro certificado y las claves asociadas a ellos, tanto privada como p\u00fablica y para ello empezamos creando el directorio <code>/etc/nginx/ssl</code>.</p> <p></p> <p>Cuando ya hayamos creado el directorio crearemos una clave p\u00fablica, donde:</p> <ul> <li><code>openssl</code> es la herramienta para crear y administrar certificados y claves.</li> <li><code>-req</code> genera una solicitud de certificados y solicitudes de firma.</li> <li><code>-x509</code> modifica el subcomando anterior diciendole que queremos crear un certificado autofirmado en lugar de una solicitud de firma.</li> <li><code>-nodes</code> omite la opci\u00f3n de asegurar nuestro certificado con contrase\u00f1a.</li> <li><code>-days 365</code> establece el tiempo durante el cu\u00e1l el certificado ser\u00e1 v\u00e1lido.</li> <li><code>-newkey rsa: 2048</code> especifica que queremos generar un nuevo certificado y una nueva clave al mismo tiempo.</li> <li><code>-keyout</code> este par\u00e1metro le dice a OpenSSL d\u00f3nde colocar el archivo de clave privada generado que estamos creando.</li> <li><code>-out</code> dice d\u00f3nde se colocar\u00e1 el certificado que estamos creando.</li> </ul> <p></p> <p>En el apartado Organizational Unit Name, podremos <code>2DAW - DEAW - VuestroNombre</code>.</p>"},{"location":"practica2-5/#22-configuracion-ssl-en-el-proxy-inverso","title":"2.2.- Configuraci\u00f3n SSL en el proxy inverso","text":"<p>Modificaremos nuestro archivo que hizo de <code>balanceo</code> en la pr\u00e1ctica anterior, es aqu\u00ed donde realizaremos la configuraci\u00f3n para que el sitio web se conecte mediante SSL.</p> <p>Dentro del bloque <code>server {...}</code> cambiaremos el puerto de escucha <code>listen 80</code> por lo siguiente:</p> <p></p>"},{"location":"practica2-5/#3-comprobaciones","title":"3.- Comprobaciones","text":"<p>Cuando accedamos ahora a nuestro sitio web <code>https://balanceo.com</code>, nos deber\u00e1 saltar un aviso de seguridad debido a que nuestro certificado es autofirmado.</p> <p></p> <p>Clicaremos en avanzado y avanzaremos al sitio web, seguidamente veremos como carga nuestro HTML. Lo siguiente que tendremos que hacer para verificar nuestro certificado es clicar en el candado.</p> <p></p> <p>Despu\u00e9s clicamos en <code>Conexi\u00f3n No Segura</code> y despu\u00e9s en <code>M\u00e1s Informaci\u00f3n.</code>:</p> <p> </p> <p>Despu\u00e9s se abre esta ventana y clicamos en <code>Ver Certificado</code>:</p> <p></p> <p>Y aqu\u00ed podremos ver todos los detalles del certificado:</p> <p></p>"},{"location":"practica2-5/#si-ahora-intentais-acceder-a-httpbalanceo-deberiais-poder-acceder-comprobadlo-y-describid-que-pasa-y-por-que","title":"Si ahora intent\u00e1is acceder a http://balanceo, \u00bfdeber\u00edais poder acceder? Comprobadlo y describid qu\u00e9 pasa y por qu\u00e9.","text":"<p>Accederemos al sitio web por defecto de Nginx, ya que http trabaja en el puerto <code>80</code> y nosotros no tenemos un bloque creado que responda a esa petici\u00f3n.</p>"},{"location":"practica2-5/#4-redireccion-forzosa-a-https","title":"4.- Redirecci\u00f3n forzosa a HTTPS","text":"<p>Para redireccionar \"forzosamente\" una petici\u00f3n http a nuestro servidor https, crearemos un bloque <code>server {...}</code> adicional en nuestro archivo de configuraci\u00f3n de balanceo:</p> <p></p> <p>Guardamos los cambios y ahora haremos un <code>sudo unlink /etc/nginx/sites-enabled/archivoBalanceo</code> y crearemos un nuevo enlace simb\u00f3lico con <code>sudo ln /etc/nginx/sites-available/balanceo /etc/nginx/sites-enabled</code> y por \u00faltimo reiniciamos nuestro servicio de Nginx.</p> <p></p> <p>Haciendo esto, cuando accedamos a <code>http://balanceo.com</code>, autom\u00e1ticamente se redigir\u00e1 a <code>https://balanceo.com</code>.</p>"},{"location":"practica2-5/#5-cuestiones-finales","title":"5.- Cuestiones finales","text":""},{"location":"practica2-5/#cuestion-1-hemos-configurado-nuestro-proxy-inverso-con-todo-lo-que-nos-hace-falta-pero-no-nos-funciona-y-da-un-error-del-tipo-this-site-cant-provide-a-secure-connection-err_ssl_protocol_error","title":"Cuesti\u00f3n 1.- Hemos configurado nuestro proxy inverso con todo lo que nos hace falta pero no nos funciona y da un error del tipo This site can't provide a secure connection, ERR_SSL_PROTOCOL_ERROR.","text":"<p>Dentro de nuestro server block tenemos esto:</p> <pre><code>server {\nlisten 443;\nssl_certificate /etc/nginx/ssl/enrico-berlinguer/server.crt;\nssl_certificate_key /etc/nginx/ssl/enrico-berlinguer/server.key;\nssl_protocols TLSv1.3;\nssl_ciphers ECDH+AESGCM:DH+AESGCM:ECDH+AES256:DH+AES256:ECDH+AES128:DH+AES:ECDH+3DES:DH+3DES:RSA+AESGCM:RSA+AES:RSA+3DES:!aNULL:!MD5:!DSS;\nserver_name enrico-berlinguer;\naccess_log /var/log/nginx/https_access.log;\n\n    location / {\n        proxy_pass http://red-party;\n        }\n    }\n</code></pre>"},{"location":"practica2-5/#respuesta","title":"Respuesta","text":"<p>El error se encuentra en el listen, que no est\u00e1 escuchando que sea ssl. Se arreglar\u00eda as\u00ed:  server { listen 443; ... }</p>"},{"location":"practica2-5/#cuestion-2-imaginad-que-intentamos-acceder-a-nuestro-sitio-web-https-y-nos-encontramos-con-el-siguiente-error-investigad-que-esta-pasando-y-como-se-ha-de-solucionar","title":"Cuesti\u00f3n 2.- Imaginad que intentamos acceder a nuestro sitio web HTTPS y nos encontramos con el siguiente error: Investigad qu\u00e9 est\u00e1 pasando y como se ha de solucionar.","text":""},{"location":"practica2-5/#respuesta_1","title":"Respuesta","text":"<p>Esto significa que nuestro certificado SSL ha sido anulado. Para solucionarlo deberemos comprobar lo siguiente:</p> <ul> <li>Verificar la validez del certificado.</li> <li>Reemplazar el certificado SSL.</li> <li>Reiniciar el servidor de Nginx.</li> <li>Verificar la configuraci\u00f3n del certificado.</li> <li>Limpiar la cach\u00e9 del navegador.</li> </ul>"},{"location":"Tema%203/practica3-1/","title":"Pr\u00e1ctica 3.1.- Instalaci\u00f3n de Tomcat","text":""},{"location":"Tema%203/practica3-1/#1-instalacion-de-tomcat","title":"1.- Instalaci\u00f3n de Tomcat","text":"<p>El primer paso para instalar Tomcat ser\u00e1 abrir el puerto por defecto usando el comando: <code>sudo ufw allow 8080</code>. </p> <p>Despu\u00e9s ejecutamos un <code>sudo apt update</code> para actualizar los paquetes. </p> <p>El siguiente paso ser\u00e1 instalar Java mediante el comando: <code>sudo apt install default-jre</code>. </p> <p>Verificamos la versi\u00f3n instalada de java con <code>java -version</code>. </p> <p>Ahora instalamos Apache Tomcat y el Tomcat-admin a trav\u00e9s del comando <code>sudo apt install tomcat10 tomcat10-admin</code>. </p> <p>Tras instalar Tomcat, modificaremos el archivo tomcat_users.xml con el comando:  <code>sudo nano /etc/tomcat10/tomcat_users.xml</code> y deberemos a\u00f1adir: </p> <pre><code>&lt;role username=\"manager-gui&gt; /&gt;\n&lt;user username=\"manager\" password=\"TuContrase\u00f1a\" roles=\"manager-gui /&gt;\n</code></pre> <p>Tras a\u00f1adirlo en nuestro fichero, el archivo quedar\u00e1 de la siguiente forma: </p> <p>Ahora que tomcat ya est\u00e1 instalado y nuestro usuario manager-gui creado, comprobamos que esta instalado correctamente a trav\u00e9s de los comandos: <code>sudo systemctl start tomcat10</code> <code>sudo systemctl status tomcat10</code> </p> <p>Si todo ha ido bien, accedemos en el navegador a la direcci\u00f3n <code>localhost:8080/manager/html</code>, donde debe aparecernos algo as\u00ed: </p> <p>Al iniciar sesi\u00f3n, deber\u00e1 aparecernos esta pantalla. </p>"},{"location":"Tema%203/practica3-1/#2-despliegue-manual-mediante-la-gui-de-administracion","title":"2.- Despliegue manual mediante la GUI de administraci\u00f3n","text":"<p>Ahora vamos a realizar un despliegue de una aplicaci\u00f3n .WAR, para ello:</p> <ol> <li>Iniciamos sesi\u00f3n con el usuario previamente creado.</li> <li>Buscamos el apartado que nos permite desplegar una aplicaci\u00f3n: </li> <li>Buscamos la secci\u00f3n que nos permite desplegar un WAR manualmente y seleccionamos nuestro archivo. En mi caso el siguiente archivo: https://tomcat.apache.org/tomcat-6.0-doc/appdev/sample/ </li> <li>Por \u00faltimo accedemos a <code>localhost:8080/sample</code> y veremos el contenido de nuestro .war y se ver\u00eda algo as\u00ed: </li> </ol>"},{"location":"Tema%203/practica3-1/#3-despliegue-con-maven","title":"3.- Despliegue con Maven","text":"<p>Ahora desplegaremos una aplicaci\u00f3n realizada con Maven, para ello deberemos:</p> <ol> <li> <p>Actualizar los repositorios con <code>sudo apt update</code>. </p> </li> <li> <p>Instalamos Maven con <code>sudo apt install maven</code>. </p> </li> <li> <p>xxComprobamos que Maven se ha instalado correctamente viendo la versi\u00f3n instalada con el comando <code>mvn --v</code>. </p> </li> </ol>"},{"location":"Tema%203/practica3-1/#31-configuracion-de-maven","title":"3.1.- Configuraci\u00f3n de Maven","text":"<ol> <li> <p>Por temas de seguridad, deberemos tener 2 usuarios, uno que tenga el rol de <code>manager-script</code> y otro que tenga <code>manager-gui</code>. Para ello, modificaremos el archivo de usuarios de Tomcat con  <code>sudo nano /etc/tomcat10/tomcat-users.xml</code>. </p> </li> <li> <p>A\u00f1adimos un nuevo rol para manager-script y el nuevo usuario, donde le asignaremos una contrase\u00f1a que nosotros queramos.     Guardamos los cambios con <code>Ctrl + O</code> y salimos con <code>Ctrl + X</code>.</p> </li> <li> <p>Ahora editamos el archivo <code>etc/maven/settings.xml</code> para indicarle a Maven, un identificador para el servidor sobre el que vamos a desplegar. </p> </li> <li> <p>Modificamos el POM del proyecto para que haga referencia a que el despliegue se realice con el plugin de Maven. Para esto, clonaremos un repositorio de github con el comando  <code>git clone https://github.com/cameronmcnz/rock-paper-scissors.git</code> </p> </li> <li> <p>Nos siutuamos dentro del proyecto que hemos creado con: <code>cd rock-paper-scissors</code> </p> </li> <li> <p>Cambiamos de rama:  <code>git checkout patch-1</code> </p> </li> <li> <p>Tras esto, editamos el archivo POM con el comando  <code>sudo nano pom.xml</code>. </p> </li> <li> <p>A\u00f1adimos el siguiente bloque</p> </li> </ol> <pre><code>        &lt;plugin&gt;\n        &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;\n        &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;\n        &lt;version&gt;2.2&lt;/version&gt;\n        &lt;configuration&gt;\n            &lt;url&gt;http://localhost:8080/manager/text&lt;/url&gt;\n            &lt;server&gt;IdDeTuServer&lt;/server&gt;\n            &lt;path&gt;/myapp&lt;/path&gt;\n        &lt;/configuration&gt;\n        &lt;/plugin&gt;\n</code></pre> <ol> <li> <p>Quedar\u00eda de la siguiente forma: </p> </li> <li> <p>Hacemos un deploy con el comando  <code>mvn tomcat7:deploy</code> </p> <p>Si todo ha ido bien, nos aparecer\u00e1 un mensaje de color verde que pondr\u00e1 Build Success, indicandonos que se ha desplegado correctamente: </p> </li> <li> <p>Por \u00faltimo, accedemos a nuestro navegador a la direcci\u00f3n <code>localhost:8080/tuPath</code>, donde tuPath es el path que hayas configurado en el pom.xml del proyecto, y deberiamos ver lo siguiente: </p> </li> </ol>"},{"location":"Tema%203/practica3-1/#4-cuestiones","title":"4.- Cuestiones","text":"<ol> <li>Hab\u00e9is visto que los archivos de configuraci\u00f3n que hemos tocado contienen contrase\u00f1as en texto plano, por lo que cualquiera con acceso a ellos obtendr\u00eda las credenciales de nuestras herramientas. En principio esto representa un gran riesgo de seguridad, \u00bfsabr\u00edas razonar o averig\u00fcar por qu\u00e9 esto est\u00e1 dise\u00f1ado de esta forma?</li> </ol> <p>Esta dise\u00f1ado de esta manera por simplicidad y compatibilidad ya que Tomcat no incluye por defecto un sistema que cifre o gestione las contrase\u00f1as. Esto es un gran problema de seguridad ya que cualquier persona podr\u00eda acceder a los datos sin estar autorizadas. Una soluci\u00f3n para cifrar las contrase\u00f1as y resolver este problema de seguridad ser\u00eda a trav\u00e9s del la herramienta <code>Apache Tomcat Jasypt</code>.</p>"},{"location":"Tema%203/practica3-2/","title":"Pr\u00e1ctica 3.2: Despliegue de aplicaciones con Node Express","text":"<p>El primer paso para esta pr\u00e1ctica sera parar el servidor Tomcat, ya que si no, este nos dar\u00e1 problemas, para ello lo paramos con el comando:  <code>sudo systemctl stop tomcat10</code> </p>"},{"location":"Tema%203/practica3-2/#1-instalacion-de-nodejs-express-y-test-de-la-primera-aplicacion","title":"1.- Instalaci\u00f3n de Node.js, Express y test de la primera aplicaci\u00f3n","text":"<p>Para instalar NodeJS, el primer paso es actualizar los paquetes del sistema mediante un <code>sudo apt update</code>. </p> <p>Tras actualizar los paquetes del sistema, instalamos NodeJS con el comando <code>sudo apt -y install nodejs npm</code>. </p> <p>Cuando lo tengamos instalado, instalamos tambien ExpressJS con el comando <code>sudo npm install -g express</code>. </p> <p>Ahora creamos un nuevo directorio con <code>mkdir</code> donde crearemos nuestra primera aplicacion de prueba. Despues nos meteremos dentro de la carpeta con <code>cd</code> e inicializamos el proyecto con el comando <code>npm init -y</code>. </p> <p>Ahora instalamos ExpressJS localmente en este proyecto con el comando <code>npm install express</code>. </p> <p>Tras eso creamos un nuevo fichero con <code>sudo nano app.js</code> donde configuraremos nuestra primera app y a\u00f1adimos el siguiente bloque:</p> <pre><code>const express = require('express')\nconst app = express()\nconst port = 3000\n\napp.get('/', (req, res) =&gt; {\n    res.send('Hello. Welcome to this blog')\n})\n\napp.listen(port, () =&gt; {\n    console.log(`Example app listening at http://localhost:${port}`)\n})\n</code></pre> <p>Quedaria de la siguiente forma: </p> <p>Y por ultimo corremos la aplicaci\u00f3n <code>node app.js</code> y deberiamos ver en la consola el siguiente mensaje:  </p> <p>Y si accedemos al navegador veremos el contenido del archivo:  </p>"},{"location":"Tema%203/practica3-2/#2-despliegue-de-una-nueva-aplicacion","title":"2.- Despliegue de una nueva aplicaci\u00f3n","text":"<p>Para este paso, clonaremos un repositorio de github de un proyecto ya creado con el comaando <code>git clone https://github.com/contentful/the-example-app.nodejs.git</code> </p> <p>Nos metemos dentro del directorio con <code>cd the-example-app.nodejs</code> e instalamos las librerias neecesarias con <code>npm install</code> </p> <p>Cuando se complete la instalaciun de las librerias, podremos iniciar la aplicacion con el comando <code>npm run start:dev</code> </p> <p>Nos metemos en el navegador y vemos el contenido: </p>"},{"location":"Tema%203/practica3-2/#3-cuestiones","title":"3.- Cuestiones","text":"<ol> <li>Cuando ejecut\u00e1is el comando npm run start:dev, lo que est\u00e1is haciendo es ejecutar un script. \u00bfDonde podemos ver que script se est\u00e1 ejecutando?    En el fichero package.json. En este fichero estan establecidos todos los comanmdos disponibles relaacionados con la aplicacion.     \u00bfQu\u00e9 comando est\u00e1 ejecutando?    Esta ejecutando node ./bin/www.</li> </ol>"},{"location":"Tema%203/practica3-2/#parte-2-despliegue-con-netlify","title":"Parte 2.- Despliegue con Netlify","text":"<p>Para comenzar con el despliegue en Netlify, empezaremos clonando un nuevo repositorio de github con <code>git clone</code>, que ser\u00e1 <code>https://github.com/StackAbuse/color-shades-generator</code> </p> <p>Accedemos al repositorio que acabamos de crear con <code>cd</code> e instalamos los m\u00f3dulos necesarios de netlify con el comando <code>sudo npm install netlify-cli -g</code> </p> <p>El siguiente paso ser\u00e1 crearnos una cuenta en Netlify y generar un token. Despu\u00e9s de registrarnos veremos la siguiente pantalla:  </p> <p>Pulsamos en New access token en el apartado de Personal access tokens y seguimos los siguientes pasos: </p> <p>Tras eso, pulsamos en <code>Generate Token</code> y ya tendremos nuestro token disponible. El siguiente paso es exportar nuestro token almancenandolo en una variable, eso lo hacemos con el comando:  <code>export NETLIFY_AU $Token</code>. </p> <p>Ahora ya podremos loguearnos con <code>netlify login</code>. Tras poner este comando se nos abrir\u00e1 el navegador pidiendo que autoricemos, pulsamos en autorizar y nos aparecer\u00e1 lo siguiente en la terminal:  </p> <p>Primero, deberemos instalar todas las dependencias con el comando <code>npm install</code> </p> <p>Y cuando ya las tengamos instaladas hacemos un <code>npm run build</code> </p> <p>Tras esto, ya podemos hacer un <code>netlify deploy</code> para desplegar nuestra aplicaci\u00f3n. </p> <ol> <li>Seleccionamos la opcion de <code>Crear y configurar un nuevo sitio</code>.</li> <li>Seleccionamos el <code>Equipo</code>.</li> <li>Asignamos un nombre.</li> <li>Asignamos la ruta de despliegue del proyecto clonado, es decir, <code>./build</code>.    </li> </ol> <p>Si todo ha ido bien, nos apareceran estos mensajes:  </p> <p>Cogemos la direccion del apartado <code>Website draft URL</code> y comprobamos que se vea el contenido: </p> <p>Ahora realizaremos el despliegue a producci\u00f3n con el comando: <code>netlify deploy --prod</code> </p> <p>Cogemos el \u00faltimo enlace y comprobamos que se ve el contenido: </p>"},{"location":"Tema%203/practica3-2/#21-despliegue-mediante-conexion-con-github","title":"2.1.- Despliegue mediante conexi\u00f3n con Github","text":"<p>Para realizar este paso, vamos a eliminar el despliegue que hab\u00edamos creado anteriormente. </p> <p>Ahora eliminamos el repositorio que clonamos anteriormente con el comando <code>rm -rf color-shades-generator</code>: </p> <p>Tras estos pasos, importamos un archivo .zip de un repositorio a trav\u00e9s del comando:  <code>wget https://github.com/StackAbuse/color-shades-generator/archive/refs/heads/main.zip</code> </p> <p>Tras importar el archivo, creamos un nuevo directorio con <code>mkdir</code> donde descomprimiremos el archivo con el comando <code>sudo unzip main.zip -d $NombreDirectorio</code>. </p> <p>Ahora accedemos al directorio y creamos un nuevo repositorio en Github:  </p> <p>Tras esto, seguimos los siguientes comandos:</p> <pre><code>sudo git init\nsudo git add .\nsudo git commit -m \"Subiendo el codigo\"\nsudo git branch -M main\n</code></pre> <p> </p> <p>Y ahora solo queda referenciar la carpeta al repositorio, para ello usamos los siguientes comandos: </p> <pre><code>sudo git remote add origin https://github.com/arammes003/practica3-2.git\nsudo git push -u origin main\n</code></pre> <p> </p> <p>Ahora que ya est\u00e1 enlazado el c\u00f3digo a Github, entraremos en el sitio web de Netlify y desde el dashboard le daremos a importar un proyecto existente de <code>git</code>. </p> <p>Le indicamos concretamente que sea de Github: </p> <p>Y nos saltar\u00e1 una ventana pidiendo que autoricemos a Netlify a acceder a nuestros repositorios de Github: </p> <p>Luego le indicamos que no acceda a todos nuestros repositorios, si no s\u00f3lo al repositorio de la pr\u00e1ctica.</p> <p></p> <p>El pr\u00f3ximo paso es desplegar la aplicaci\u00f3n.  </p> <p>IMPORTANTE Tras el deploy, deberemos cambiar el nombre de la aplicaci\u00f3n por nombre-practica3-4. </p> <ul> <li> <p>Ahora vamos a comprobar que el nombre se ha cambiado correctamente, para ello dentro de la carpeta <code>public</code> encontramos el archivo <code>robots.txt</code> cuyo objetivo es indicar a los rastreadores de los buscadores a que URLs del sitio pueden acceder. </p> </li> <li> <p>Dentro de la carpeta <code>public</code>, utilizaremos un editor de texto para modificar el archivo <code>robots.txt</code> y pondremos nuestro nombre y apellido.  </p> </li> <li> <p>Hacemos un nuevo commit para que se apliquen los cambios de manera autom\u00e1tica.  </p> </li> </ul> <p>Y lo podremos comprobar en nuestra p\u00e1gina de Netlify tras realizar el push.  </p> <p>Y tras ello, tambi\u00e9n lo comprobamos en el navegador web. </p>"},{"location":"Tema%203/practica3-2/#3-cuestiones_1","title":"3.- Cuestiones","text":"<ol> <li>Investiga y explica que es un Dyno en terminolog\u00eda Heroku.</li> </ol> <p>Es una unidad de ejecuci\u00f3n ligera que se utiliza para ejecutar aplicaciones en la plataforma.</p> <ol> <li>En Heroku no todo es de color de rosa, tiene sus limitaciones y desventajas. Busca, investiga y explica algunas de ellas detalladamente. </li> </ol> <p>Tiene costos elevados: Escalar aplicaciones en Heroku puede volverse caro, especialmente al usar m\u00faltiples Dynos o bases de datos grandes\u200b.</p> <p>Limitaciones del plan gratuito: Restricciones en horas de uso, suspensi\u00f3n tras inactividad, y bajo rendimiento, lo que lo hace poco ideal para producci\u00f3n.\u200b</p> <p>Rendimiento variable: No es \u00f3ptimo para aplicaciones con alto tr\u00e1fico o necesidades avanzadas sin costosos upgrades\u200b.</p> <p>Falta de soporte avanzado: Configuraciones complejas o tecnolog\u00edas modernas como Jamstack no est\u00e1n tan bien soportadas como en otras plataformas como AWS o Vercel\u200b.</p> <p>Dependencia del ecosistema: Migrar desde Heroku puede ser complicado y costoso\u200b.</p>"},{"location":"Tema%203/practica3-3/","title":"Pr\u00e1ctica 3.3.- Despliegue de una aplicaci\u00f3n Flask","text":"<p>Antes de empezar con el despliegue, nos conectaremos mediante SSH desde nuestra m\u00e1quina a la m\u00e1quina Debian mediante el comando <code>ssh nombreUsuarioDebian@direccionIpDebian</code>, de la siguiente manera:</p> <p></p>"},{"location":"Tema%203/practica3-3/#1-procedimiento-para-el-despliegue","title":"1.- Procedimiento para el despliegue","text":"<p>Para realizar el despligue de una aplicaci\u00f3n Flask seguiremos una serie de pasos:</p> <ol> <li> <p>Actualizamos los repositorios de paquetes del sistema con <code>sudo apt update</code>. </p> </li> <li> <p>Instalamos el gestor de paquetes de Python con <code>sudo apt install python3-pip</code>. </p> </li> <li> <p>Instalamos el paquete pipenv que se encarga de gestionar los entornos virtuales con  <code>sudo apt install pipenv</code>. </p> </li> <li> <p>Comprobamos que est\u00e1 bien instalado mostrando su vesi\u00f3n con <code>pipenv --version</code>. </p> </li> <li> <p>Creamos el directorio donde almacenaremos nuestro proyecto con  <code>sudo mkdir /var/www/nombreAplicacion</code>. </p> </li> <li> <p>Como lo creamos con <code>sudo</code>, los permisos pertenecen al usuario <code>root</code> del sistema: </p> </li> <li> <p>Hay que cambiarle los permisos para que pertenezcan a nuestro usuario (debianalfonso en mi caso) y pertenezca al grupo www-data con el siguiente comando  <code>sudo chwn -r USUARIO:www-data /var/www/nombreAplicacion</code> </p> </li> <li> <p>Establecemos los permisos adecuados para que pueda ser le\u00eddo por todo el mundo con <code>sudo chmod -R 775 /var/www/nombreAplicacion</code>. </p> </li> <li> <p>Dentro del directorio de nuestra aplicaci\u00f3n, creamos un archivo oculto <code>.env</code> que contendr\u00e1 las variables de entorno con el comando <code>touch .env</code>. </p> </li> <li> <p>Editamos el archivo y a\u00f1adimos las variables, indicando cu\u00e1l es el archivo <code>.py</code> de la aplicaci\u00f3n y el entorno, que en nuestro caso ser\u00e1 production. Para editarlo usamos el comando: <code>sudo nano .env</code> y despu\u00e9s verificamos los cambios con <code>cat .env</code>. </p> </li> <li> <p>Iniciamos el entorno virtual mediante <code>pipenv shell</code>. Pipenv cargar\u00e1 las variables de entorno desde el fichero <code>.env</code> de forma autom\u00e1tica. </p> </li> <li> <p>Ahora usamos <code>pipenv install flask gunicorn</code> para instalar las dependencias necesarias para nuestro proyecto. </p> </li> <li> <p>Ahora vamos a crear nuestra aplicaci\u00f3n Flask lo m\u00e1s r\u00e1pido posible. Para ello crearemos dos archivos, <code>application.py</code> y <code>wsgi.py</code> con este contenido respectivamente, mediante el comando <code>touch application.py wsgi.py</code> </p> </li> <li> <p>Ahora a\u00f1adimos el contenido a cada archivo.</p> </li> </ol> <p>Archivo application.py:</p> <pre><code>from flask import Flask\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n        return '&lt;h1&gt;Aplicacion desplegada&lt;/h1&gt;'\n</code></pre> <p></p> <p>Archivo wsgi.py:</p> <pre><code>from application import app\n\nif __name__ == '__main__':\n        app.run(debug=False)\n\n</code></pre> <p></p> <ol> <li> <p>Ahora iniciamos nuestra aplicaci\u00f3n con <code>flask run --host '0.0.0.0'</code> a modo de comprobaci\u00f3n con el servidor web integrado en Flask. Si especificamos la direcci\u00f3n <code>0.0.0.0</code> lo que estamos diciendo al servidor es que escuche a todas sus interfaces en caso de tenerlas.  </p> </li> <li> <p>Ahora accedemos desde nuestro navegador a la direcci\u00f3n IP <code>http://IP-maq-virtual:5000</code> y deber\u00edamos ver lo siguiente: </p> </li> <li> <p>Tras esto, paramos el servidor con <code>CTRL + C</code>.</p> </li> <li> <p>Ahora comprobaremos que Gunicor funciona correctamente mediante el comando <code>gunicorn -workers 4 --bind 0.0.0.0:5000 wsgi:app</code>. Si con el servidor de desarrollo no tuvimos ningun problema, deberiamos verlo perfectamente en nuestro navegador: </p> </li> <li> <p>Todav\u00eda dentro del entorno virtual, debemos obtener la ruta desde donde se ejecuta gunicorn para poder configurar m\u00e1s adelante un servicio del sistema con el comando <code>which gunicorn</code>: </p> </li> <li> <p>Por \u00faltimo, salimos del entorno virtual con <code>deactivate</code>. </p> </li> </ol>"},{"location":"Tema%203/practica3-3/#2-despliegue-con-nginx","title":"2.- Despliegue con Nginx","text":"<p>Iniciamos Nginx y comprobamos que su estado sea activo:</p> <pre><code>sudo systemctl start nginx\n\nsudo systemctl status nginx\n</code></pre> <p></p> <ol> <li> <p>Creamos un archivo con <code>sudo nano /etc/systemd/system/nombreArchivo</code> para que <code>systemd</code> corra Gunicorn como un servicio m\u00e1s del sistema: </p> </li> <li> <p>Ahora habilitamos el servicio con <code>systemctl enable nombreServicio</code> y lo iniciamos con <code>systemctl start nombreServicio</code>. </p> </li> <li> <p>Ahora crearemos un archivo de configuraci\u00f3n en Nginx con <code>sudo nano /etc/nginx/sites-available/nombreAplicacion</code> y ponemos lo siguiente:</p> </li> </ol> <pre><code>server {\n    listen 80;\n    server_name mi_aplicacion www.mi_aplicacion;\n\n    access_log /var/log/nginx/mi_aplicacion.access.log;\n    error_log /var/log/nginx/mi_aplicacion.error.log;\n\n    location / { \n            include proxy_params;\n            proxy_pass http://unix:/var/www/nombre_aplicacion/nombre_aplicacion.sock;\n    }\n}   \n</code></pre> <p></p> <ol> <li> <p>Ahora creamos un enlace simb\u00f3lico con <code>sudo ln -s /etc/nginx/sites-available/aplicacionFlask /etc/nginx/sites-enabled/</code> y nos aseguramos que se ha creado el enlace con <code>ls -l /etc/nginx/sites-enabled/ | grep aplicacionFlask</code>. </p> </li> <li> <p>Comprobamos que el archivo de configuraci\u00f3n no contiene errores, reiniciamos Nginx y comprobamos que este activo:</p> </li> </ol> <pre><code>nginx -t\n\nsudo systemctl restart nginx\n\nsudo systemctl status nginx\n</code></pre> <p></p> <ol> <li> <p>Ahora la \u00fanica manera de acceder a nuestra aplicaci\u00f3n es mediante el <code>server_name</code>. Para ello, editamos el archivo <code>/etc/hosts</code> de nuestra m\u00e1quina para que asocie la IP de la m\u00e1quina virtual a nuestro <code>server_name</code>. </p> </li> <li> <p>El \u00faltimo paso es acceder mediante nuestro navegador:  </p> </li> </ol>"},{"location":"Tema%203/practica3-3/#3-ejercicio","title":"3.- Ejercicio","text":"<p>Repite todo el proceso con la aplicaci\u00f3n del siguiente repositorio: https://github.com/raul-profesor/Practica-3.5.</p> <p>Clonamos el repositorio en nuestro direectorio <code>/var/www</code> con el comando <code>sudo git clone https://github.com/raul-profesor/Practica-3.5</code>. </p> <p>Cambiamos el due\u00f1o a nuestro usuario con el comando <code>sudo chown -R USUARIO:www-data /var/www/nombreAplicacion</code>. </p> <p>Establecemos los permisos adecuados con <code>chmod -R 775 /var/www/nombreAplicacion</code>.  </p> <p>Creamos un archivo oculto <code>.env</code> dentro del directorio de nuestra aplicaci\u00f3n con <code>touch .env</code>. </p> <p>Editamos el archivo con <code>sudo nano .env</code> y despu\u00e9s vemos los cambios con <code>cat .env</code>. </p> <p>Ahora iniciamos nuestro entorno virtual con <code>pipenv shell</code> para que cargue las variables de entorno desde el fichero <code>.env</code>. </p> <p>Ahora instalamos las dependencias  con <code>pipenv install -r requirements.txt</code>. </p> <p>Instalamos <code>gunicorn</code> con el comando <code>pipenv install flask gunicorn</code>. </p> <p>Creamos un archivo <code>wsgi.py</code> que contendr\u00e1 lo siguiente: </p> <p>Por \u00faltimo, corremos nuestra aplicaci\u00f3n con <code>flask run --host '0.0.0.0'</code>; </p> <p>Y comprobamos que podemos acceder mediante <code>gunicorn --workers 4 --bind 0.0.0.0:8000 wsgi:app</code>. </p> <p>Usamos el comando <code>which gunicorn</code> para poder configurar m\u00e1s tarde un servicio. </p> <p>Ya podemos salir del entorno virtual con <code>deactivate</code>. </p>"},{"location":"Tema%203/practica3-3/#31-nginx","title":"3.1.- Nginx","text":"<p>Ahora vamos a desplegarla en Nginx, para ello:</p> <ol> <li> <p>Creamos un archivo para que <code>systemd</code> corra Gunicorn como un servicio m\u00e1s:  </p> </li> <li> <p>Ahora habilitamos el servicio con <code>systemctl enable nombreServicio</code> y lo iniciamos con <code>systemctl start nombreServicio</code>. </p> </li> <li> <p>Creamos un archivo donde configuraremos el sitio web de Nginx con <code>sudo nano /etc/nginx/sites-available/nombreAplicacion</code>. </p> </li> <li> <p>Creamos un enlace simb\u00f3lico con <code>sudo ln -s /etc/nginx/sites-available/nombreAplicacion /etc/nginx/sites-enabled/</code>. </p> </li> <li> <p>Nos aseguramos que se ha creado con <code>ls -l /etc/nginx/sites-enabled | grep nombreAplicacion</code>. </p> </li> <li> <p>Comprobamos que Nginx no contiene errores con <code>nginx -t</code>, lo reiniciamos con <code>sudo systemctl restart nginx</code> y vemos su estado con <code>sudo systemctl status nginx</code>.  </p> </li> <li> <p>Lo \u00faltimo que tendremos que hacer es editar el archivo <code>/etc/hosts</code> para asociar la IP de la m\u00e1quina a nuestro <code>server_name</code>. </p> </li> <li> <p>Accedemos al navegador y si todo ha ido bien veremos el siguiente contenido: </p> </li> </ol>"},{"location":"Tema%203/practica3-3/#4-cuestiones","title":"4.- Cuestiones","text":""},{"location":"Tema%203/practica3-3/#41-busca-lee-entiende-y-explica-que-es-y-para-que-sirve-un-servidor-wsgi","title":"4.1.- Busca, lee, entiende y explica qu\u00e9 es y para que sirve un servidor WSGI.","text":"<p>Un servidor WSGI es un est\u00e1ndar que define c\u00f3mo los servidores web deben comunicarse con las aplicaciones web Python. Permite que aplicaciones como Flask o Django procesen solicitudes HTTP y generen respuestas.  Sirve para: - Conectar la aplicaci\u00f3n Python con servidores web como NGINX o Apache. - Procesar solicitudes HTTP y devolver respuestas a los usuarios. - Mejorar el rendimiento mediante la gesti\u00f3n de m\u00faltiples procesos de trabajo (workers).</p>"}]}